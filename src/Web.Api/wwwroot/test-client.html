<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-AI Chat API Test Client</title>
    <style>
        :root {
            --primary-color: #4a7bff;
            --primary-hover: #3a6aee;
            --secondary-color: #6c757d;
            --secondary-hover: #5a6268;
            --success-color: #28a745;
            --success-hover: #218838;
            --warning-color: #ffc107;
            --warning-hover: #e0a800;
            --danger-color: #dc3545;
            --danger-hover: #c82333;
            --light-gray: #f8f9fa;
            --medium-gray: #e9ecef;
            --dark-gray: #343a40;
            --text-color: #212529;
            --border-color: #dee2e6;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --border-radius: 0.5rem;
            --box-shadow: 0 2px 8px rgba(0,0,0,0.12), 0 1px 3px rgba(0,0,0,0.08);
            --transition-speed: 0.2s;
        }

        body {
            font-family: var(--font-family);
            max-width: 1280px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--light-gray);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .settings-panel, .chat-container > div {
            background-color: white;
            padding: 25px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            box-shadow: var(--box-shadow);
            border: 1px solid var(--border-color);
            transition: box-shadow var(--transition-speed) ease;
        }

        .settings-panel:hover, .chat-container > div:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.1);
        }

        .chat-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 20px;
            height: calc(100vh - 220px); /* Adjust height */
            min-height: 400px;
        }

        .message-area {
            flex: 1 1 60%; /* Allow shrinking but prefer wider */
            min-width: 300px; /* Minimum width */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent content overflow */
        }

        .token-usage {
            padding: 8px 15px;
            background-color: var(--light-gray);
            border-bottom: 1px solid var(--border-color);
            color: var(--secondary-color);
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
        }

        .token-usage-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .token-usage-item .value {
            font-weight: 500;
            color: var(--text-color);
        }

        .message-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .message-input-area {
            border-top: 1px solid var(--border-color);
            padding: 15px;
            background-color: var(--light-gray);
        }

        .message-input {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message-input textarea {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            resize: none;
            font-family: inherit;
            font-size: 1rem;
            min-height: 40px; /* Ensure decent height */
            max-height: 150px; /* Limit excessive growth */
            overflow-y: auto;
        }

        .message-input textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color), 0.25);
        }

        .input-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .status-indicator {
            font-size: 0.9em;
            color: var(--secondary-color);
            text-align: center;
            padding-top: 5px;
            height: 1.5em; /* Reserve space */
        }

        .btn {
            display: inline-flex; /* Align icon and text */
            align-items: center;
            justify-content: center;
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            text-decoration: none;
            white-space: nowrap;
        }

        .btn:hover {
            background-color: var(--primary-hover);
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        }

        .btn:disabled {
            background-color: var(--medium-gray);
            color: var(--secondary-color);
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-secondary {
            background-color: var(--secondary-color);
        }
        .btn-secondary:hover {
            background-color: var(--secondary-hover);
        }
        .btn-success {
            background-color: var(--success-color);
        }
        .btn-success:hover {
            background-color: var(--success-hover);
        }
        .btn-danger {
            background-color: var(--danger-color);
        }
        .btn-danger:hover {
            background-color: var(--danger-hover);
        }
        .btn-warning {
            background-color: var(--warning-color);
            color: var(--dark-gray);
        }
        .btn-warning:hover {
            background-color: var(--warning-hover);
        }

        .btn-icon {
            padding: 8px;
            font-size: 1.2rem;
            line-height: 1;
        }

        .uploads-panel {
            flex: 1 1 30%; /* Allow shrinking but prefer narrower */
            min-width: 250px;
            max-width: 350px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .uploads-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding: 5px;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-bottom: 8px;
            background-color: var(--light-gray);
        }

        .file-item img, .file-item .file-icon {
            width: 40px;
            height: 40px;
            object-fit: cover;
            margin-right: 10px;
            border-radius: 4px;
            flex-shrink: 0;
        }

        .file-item .file-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--medium-gray);
        }

        .file-info {
            flex: 1;
            overflow: hidden;
            font-size: 0.9em;
        }

        .file-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .file-size {
            color: var(--secondary-color);
            font-size: 0.8em;
        }

        .file-actions {
            display: flex;
            gap: 5px;
        }

        .file-actions .btn-icon {
            background: none;
            border: none;
            color: var(--secondary-color);
            cursor: pointer;
            font-size: 1rem;
            padding: 4px;
        }
        .file-actions .btn-icon:hover {
            color: var(--danger-color);
        }

        .message {
            max-width: 85%;
            margin-bottom: 15px;
            padding: 10px 15px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
            box-shadow: 0 1px 1px rgba(0,0,0,0.08);
        }

        .message .message-content {
            overflow-wrap: break-word;
        }

        .edit-btn {
            opacity: 0;
            transition: opacity 0.2s;
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255, 255, 255, 0.7);
            border: none;
            border-radius: 50%;
            padding: 3px 6px;
            cursor: pointer;
            font-size: 0.8em;
            line-height: 1;
            color: var(--dark-gray);
        }

        .message:hover .edit-btn {
            opacity: 1;
        }

        .message.user {
            align-self: flex-end;
            background-color: var(--primary-color);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 6px;
        }

        .message.ai {
            align-self: flex-start;
            background-color: white;
            color: var(--text-color);
            border: 1px solid var(--medium-gray);
            margin-right: auto;
            border-bottom-left-radius: 6px;
        }

        .message.ai pre {
            background-color: #2d2d2d;
            color: #f8f9fa;
        }

        .file-attachments {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .file-attachment {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow: hidden;
            width: 150px;
            background-color: white;
        }

        .file-attachment img {
            width: 100%;
            height: 100px;
            object-fit: cover;
            display: block;
        }

        .file-attachment .attachment-name {
            padding: 8px;
            font-size: 0.85em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
            background-color: var(--light-gray);
        }

        .connection-status {
            padding: 8px 12px;
            text-align: center;
            margin-bottom: 10px;
            border-radius: var(--border-radius);
            font-weight: 500;
            font-size: 0.9em;
        }

        .connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .loading {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }

        .hidden {
            display: none !important; /* Use important to ensure override */
        }

        #fileInput {
            display: none;
        }

        .status-message {
            font-style: italic;
            color: var(--secondary-color);
            text-align: center;
            padding: 20px 10px;
            font-size: 0.9em;
        }

        /* Toast notification styles */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            width: 300px;
        }

        .toast {
            background-color: var(--dark-gray);
            color: white;
            padding: 15px 20px;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            transform: translateX(100%);
            font-size: 0.95em;
        }

        .toast.error { background-color: var(--danger-color); }
        .toast.success { background-color: var(--success-color); }
        .toast.info { background-color: var(--primary-color); }
        .toast.warning { background-color: var(--warning-color); color: var(--dark-gray); }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        /* Code block styling */
        pre {
            background-color: var(--dark-gray);
            color: var(--light-gray);
            padding: 15px;
            border-radius: var(--border-radius);
            overflow-x: auto;
            margin: 10px 0;
        }

        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            font-size: 0.9em;
        }

        pre code {
            white-space: pre;
            display: block;
            word-wrap: normal; /* Prevent wrapping inside code blocks */
        }

        /* Basic Markdown */
        strong, b { font-weight: 600; }
        em, i { font-style: italic; }

        /* Add styles for error messages */
        .error-message {
            color: var(--danger-color);
            padding: 10px;
            margin: 10px 0;
            border-radius: var(--border-radius);
            background-color: rgba(var(--danger-color), 0.1);
            border-left: 4px solid var(--danger-color);
            font-size: 0.9em;
        }

        /* Add styles for button groups */
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Add more efficient loading indicator */
        .loading-indicator {
            display: inline-block;
            width: 1em;
            height: 1em;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive improvements */
        @media (max-width: 768px) {
            .chat-container {
                flex-direction: column;
            }

            .message-area, .uploads-panel {
                flex: 1 1 100%;
                min-width: 100%;
                max-width: 100%;
            }
        }

        /* Add this CSS for more prominent stop button */
        .btn-stop {
            background-color: var(--danger-color);
            color: white;
            padding: 8px 15px;
            border-radius: var(--border-radius);
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s ease;
            z-index: 10; /* Make sure it's above other elements */
        }
        
        .btn-stop:hover {
            background-color: var(--danger-hover);
        }
        
        .btn-stop:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
        }

        .btn-stop.hidden {
            display: none !important;
        }
    </style>
</head>
<body>
<div class="toast-container" id="toastContainer"></div>
<div class="settings-panel">
    <h2 style="margin-top:0;">Multi-AI Chat API Test Client</h2>
    <div style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 10px;">
        <div style="flex: 1; min-width: 200px;">
            <label for="tokenInput" style="display: block; margin-bottom: 5px; font-weight: 500;">Auth Token:</label>
            <input type="text" id="tokenInput" style="width: 100%; padding: 8px; box-sizing: border-box; border-radius: var(--border-radius); border: 1px solid var(--border-color);" placeholder="Enter your auth token">
        </div>
        <div style="flex: 1; min-width: 200px;">
            <label for="chatIdInput" style="display: block; margin-bottom: 5px; font-weight: 500;">Chat Session ID:</label>
            <input type="text" id="chatIdInput" style="width: 100%; padding: 8px; box-sizing: border-box; border-radius: var(--border-radius); border: 1px solid var(--border-color);" placeholder="Enter chat session ID">
        </div>
    </div>
    <div class="button-group" style="margin-top: 15px;">
        <button id="connectBtn" class="btn btn-success">Connect</button>
        <button id="disconnectBtn" class="btn btn-danger" disabled>Disconnect</button>
    </div>
    <div id="connectionStatus" class="connection-status disconnected" style="margin-top: 15px;">
        Disconnected
    </div>
</div>

<div class="chat-container">
    <div class="message-area">
        <div class="token-usage">
            <div class="token-usage-item">
                <span>Input:</span> 
                <span class="value" id="inputTokens">0</span>
            </div>
            <div class="token-usage-item">
                <span>Output:</span> 
                <span class="value" id="outputTokens">0</span>
            </div>
            <div class="token-usage-item">
                <span>Total:</span> 
                <span class="value" id="totalTokens">0</span>
            </div>
            <div class="token-usage-item">
                <span>Cost:</span> 
                <span class="value" id="tokenCost">$0.00</span>
            </div>
        </div>
        <div id="messageList" class="message-list">
            <div class="status-message">Connect to start chatting</div>
        </div>
        <div class="message-input-area">
            <div class="message-input">
                <textarea id="messageInput" placeholder="Type your message..." rows="3" disabled></textarea>
                <div class="input-buttons">
                    <input type="file" id="fileInput" multiple>
                    <button id="uploadBtn" class="btn btn-secondary btn-icon" disabled title="Upload Files">
                        ðŸ“Ž
                    </button>
                    <button id="sendBtn" class="btn" disabled>Send</button>
                    <button id="stopBtn" class="btn btn-stop hidden" disabled>
                        <i class="fas fa-stop"></i> Stop
                    </button>
                </div>
            </div>
            <div class="status-indicator" id="statusIndicator">
                <!-- Thinking/Reasoning Toggle -->
            </div>

            <!-- Moved Image Settings Section -->
            <div id="imageSettingsContainer" style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed var(--border-color); font-size: 0.9em;">
                 <!-- Thinking/Reasoning Toggle moved here -->
                <div style="margin-bottom: 10px;">
                    <input type="checkbox" id="thinkingToggle" style="vertical-align: middle;">
                    <label for="thinkingToggle" style="vertical-align: middle; cursor: pointer;">Enable Thinking/Reasoning</label>
                </div>
                <!-- Image Settings -->
                <strong style="display: block; margin-bottom: 5px;">Image Generation Settings (AIMLAPI):</strong>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div>
                        <label for="imageSizeSelect">Image Size:</label>
                        <select id="imageSizeSelect" style="width: 100%; padding: 5px;">
                            <option value="" selected>(Default)</option>
                            <option value="landscape_16_9">Landscape 16:9</option>
                            <option value="landscape_4_3">Landscape 4:3</option>
                            <option value="square">Square</option>
                            <option value="square_hd">Square HD</option>
                            <option value="portrait_4_3">Portrait 4:3</option>
                            <option value="portrait_16_9">Portrait 16:9</option>
                        </select>
                    </div>
                    <div>
                        <label for="numImagesInput">Number of Images:</label>
                        <input type="number" id="numImagesInput" min="1" max="4" value="1" style="width: 100%; padding: 5px;">
                    </div>
                    <div>
                        <label for="outputFormatSelect">Output Format:</label>
                        <select id="outputFormatSelect" style="width: 100%; padding: 5px;">
                            <option value="" selected>(Default - jpeg)</option>
                            <option value="jpeg">JPEG</option>
                            <option value="png">PNG</option>
                        </select>
                    </div>
                    <div>
                        <label for="safetyToleranceSelect">Safety Tolerance:</label>
                        <select id="safetyToleranceSelect" style="width: 100%; padding: 5px;">
                            <option value="" selected>(Default - 2)</option>
                            <option value="1">1 (Strict)</option>
                            <option value="2">2 (Moderate)</option>
                            <option value="3">3 (Lenient)</option>
                        </select>
                    </div>
                    <div style="grid-column: span 2;">
                        <input type="checkbox" id="enableSafetyCheckerToggle" checked style="vertical-align: middle;">
                        <label for="enableSafetyCheckerToggle" style="vertical-align: middle;">Enable Safety Checker</label>
                    </div>
                </div>
            </div>
            <!-- End Image Settings Section -->

        </div>
    </div>
    <div class="uploads-panel">
        <h3 style="margin-top: 0;">Attachments</h3>
        <div id="uploadsList" class="uploads-list">
            <div class="status-message">No files uploaded</div>
        </div>
        <button id="clearUploadsBtn" class="btn btn-warning">Clear All</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/highlight.min.js"></script>
<script>
    // Configure marked with highlight.js for code highlighting
    marked.setOptions({
        highlight: function(code, language) {
            if (language && hljs.getLanguage(language)) {
                return hljs.highlight(code, { language: language }).value;
            } else {
                return hljs.highlightAuto(code).value;
            }
        },
        breaks: false,      // Set breaks to false to prevent auto-linebreaks
        gfm: true,
        mangle: false,      // Don't allow autolinks in the message
        headerIds: false,   // Don't add IDs to headers (not needed for chat)
        smartLists: true,   // Use smarter list behavior
    });

    // DOM Elements
    const tokenInput = document.getElementById('tokenInput');
    const chatIdInput = document.getElementById('chatIdInput');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const connectionStatus = document.getElementById('connectionStatus');
    const messageList = document.getElementById('messageList');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');
    const uploadsList = document.getElementById('uploadsList');
    const clearUploadsBtn = document.getElementById('clearUploadsBtn');
    const statusIndicator = document.getElementById('statusIndicator');
    const stopBtn = document.getElementById('stopBtn');
    const thinkingToggle = document.getElementById('thinkingToggle');
    const inputTokensEl = document.getElementById('inputTokens');
    const outputTokensEl = document.getElementById('outputTokens');
    const totalTokensEl = document.getElementById('totalTokens');
    const tokenCostEl = document.getElementById('tokenCost');

    // --- Add refs for new image setting inputs ---
    const imageSettingsContainer = document.getElementById('imageSettingsContainer');
    const imageSizeSelect = document.getElementById('imageSizeSelect');
    const numImagesInput = document.getElementById('numImagesInput');
    const outputFormatSelect = document.getElementById('outputFormatSelect');
    const enableSafetyCheckerToggle = document.getElementById('enableSafetyCheckerToggle');
    const safetyToleranceSelect = document.getElementById('safetyToleranceSelect');

    // State variables
    let connection = null;
    let isConnected = false;
    let isGenerating = false;
    let currentAiMessageId = null;
    let currentThinkingMessageId = null;
    let uploadedFiles = []; // Holds files uploaded via API, ready to be associated with a message
    const pendingRequests = new Set(); // Keep track of pending fetch/API requests to avoid duplicate actions
    let streamUpdateTimeout = null; // For debouncing UI updates during streaming
    const DEBOUNCE_DELAY = 150; // Milliseconds delay for UI update

    // --- Connection Management ---
    connectBtn.addEventListener('click', connectToHub);
    disconnectBtn.addEventListener('click', disconnectFromHub);

    async function connectToHub() {
        const token = tokenInput.value.trim();
        const chatId = chatIdInput.value.trim();

        if (!token || !chatId) {
            showToast('Please enter Auth Token and Chat Session ID', 'warning');
            return;
        }

        if (connection && connection.state === signalR.HubConnectionState.Connected) {
            console.log("Already connected.");
            return;
        }

        try {
            updateConnectionStatus('loading', 'Connecting...');
            toggleUIState(false);

            connection = new signalR.HubConnectionBuilder()
                .withUrl("/chatHub", { 
                    accessTokenFactory: () => token,
                    // skipNegotiation: true, // Consider enabling if negotiation fails
                    // transport: signalR.HttpTransportType.WebSockets // Force websockets if needed
                 })
                .withAutomaticReconnect([0, 2000, 5000, 10000, 15000, 30000]) // Default retry delays
                .configureLogging(signalR.LogLevel.Information) // Log SignalR activity
                .build();

            setupSignalREvents();

            await connection.start();
            console.log("SignalR Connected");

            // Join the chat session - this will now automatically load the history via the ReceiveChatHistory event
            await connection.invoke("JoinChatSession", chatId);
            console.log(`Joined chat session: ${chatId}`);

            updateConnectionStatus('connected', 'Connected');
            toggleConnectionState(true);

        } catch (err) {
            console.error("SignalR Connection Error:", err);
            updateConnectionStatus('disconnected', `Connection failed: ${err.message || 'Unknown error'}`);
            toggleConnectionState(false);
            connection = null; // Ensure connection state is reset
        }
    }

    async function disconnectFromHub() {
        if (connection) {
            try {
                await connection.stop();
            } catch (err) {
                console.error("Error disconnecting SignalR:", err);
            } finally {
                console.log("SignalR Disconnected");
                updateConnectionStatus('disconnected', 'Disconnected');
                toggleConnectionState(false);
                isGenerating = false;
                updateGeneratingStateUI();
                connection = null;
                messageList.innerHTML = '<div class="status-message">Disconnected.</div>';
                clearUploadedFiles(); // Clear attachments on disconnect
            }
        }
    }

    function setupSignalREvents() {
        if (!connection) return;
        
        // Handle reconnection events
        connection.onreconnecting(error => {
            console.warn("SignalR reconnecting...", error);
            updateConnectionStatus('loading', 'Reconnecting...');
        });

        connection.onreconnected(connectionId => {
            console.log("SignalR reconnected.");
            updateConnectionStatus('connected', 'Reconnected');
            toggleConnectionState(true);
        });

        connection.onclose(error => {
            console.warn("SignalR connection closed.", error);
            updateConnectionStatus('disconnected', 'Disconnected');
            toggleConnectionState(false);
            isGenerating = false;
            updateGeneratingStateUI();
            connection = null;
        });
        
        // --- Message Handlers ---
        
        // Complete messages (not streaming)
        connection.on("ReceiveMessage", (message) => {
            console.log("ReceiveMessage:", message);
            addMessageToChat(message);
            
            // If this is an AI message we were waiting for, update the generating state
            if (isGenerating && message.isFromAi && message.messageId === currentAiMessageId) {
                stopGenerationState("Message received.");
            }
        });
        
        // Message chunks for streaming responses
        connection.on("ReceiveMessageChunk", (messageId, content) => {
            console.log(`Chunk received for ${messageId}: ${content.length} chars`);
            
            try {
                if (!messageId) {
                    console.error("Received chunk with null or empty messageId");
                    return;
                }
                
                if (!isGenerating || currentAiMessageId !== messageId) {
                    console.log(`Starting new streaming for message: ${messageId}`);
                    currentAiMessageId = messageId;
                    isGenerating = true;
                    updateGeneratingStateUI("AI is responding...");
                    
                    // Show stop button
                    stopBtn.classList.remove('hidden');
                    stopBtn.disabled = false;
                }
                
                // Update the message with the new content chunk
                updateStreamingMessage(messageId, content);
            } catch (error) {
                console.error("Error handling message chunk:", error);
                showToast("Error updating message stream", "error");
            }
        });
        
        // Thinking chunks (reasoning from the AI)
        connection.on("ReceiveThinkingChunk", (messageId, content) => {
            console.log(`Thinking chunk for ${messageId}`);
            
            if (!isGenerating || currentAiMessageId !== messageId) {
                startGenerationState(messageId, "AI is thinking...");
            }
            
            updateThinkingChunk(messageId, content);
        });
        
        // File attachments
        connection.on("ReceiveFile", (fileAttachment) => {
            console.log("ReceiveFile:", fileAttachment);
            addFileAttachmentToMessage(fileAttachment.messageId, fileAttachment);
        });

        // Handle receiving chat history directly from SignalR
        connection.on('ReceiveChatHistory', (chatData) => {
            console.log('Received chat history via SignalR:', chatData);
            
            // Clear any existing messages
            messageList.innerHTML = '';
            
            if (chatData.messages && chatData.messages.length > 0) {
                console.log(`Displaying ${chatData.messages.length} history messages from SignalR`);
                
                // First sort messages by timestamp to ensure proper order
                const sortedMessages = [...chatData.messages].sort((a, b) => {
                    return new Date(a.createdAt) - new Date(b.createdAt);
                });
                
                sortedMessages.forEach(msg => {
                    console.log(`Adding history message: ${msg.id.substring(0, 8)}... (${msg.isFromAi ? 'AI' : 'User'})`);
                    // Use the same function to add messages
                    addMessageToChat({
                        messageId: msg.id, 
                        content: msg.content || "", // Ensure content is never null
                        isFromAi: msg.isFromAi,
                        timestamp: msg.createdAt 
                    });
                });
                
                // Apply code block actions after all messages are loaded
                addCodeBlockActions();
                
                // Scroll to the most recent message
                scrollToBottom();
            } else {
                messageList.innerHTML = '<div class="status-message">No messages yet. Start chatting!</div>';
            }

            // Update token usage if history provides it
            if (chatData.inputTokens !== undefined || chatData.outputTokens !== undefined) {
                updateTokenUsage(chatData.inputTokens || 0, chatData.outputTokens || 0, chatData.totalCost || 0);
            }
        });
        
        // Token usage updates
        connection.on("TokenUsageUpdated", (tokenUsage) => {
            console.log("TokenUsageUpdated:", tokenUsage);
            updateTokenUsage(tokenUsage.inputTokens || 0, tokenUsage.outputTokens || 0, tokenUsage.totalCost || 0);
        });
        
        // Response completion and stopping
        connection.on("ResponseCompleted", (messageId) => {
            console.log("ResponseCompleted for:", messageId);
            if (isGenerating && messageId === currentAiMessageId) {
                stopGenerationState();
                const finalElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
                if (finalElement) addCodeBlockActions(finalElement);
            }
        });
        
        connection.on("ResponseStopped", (messageId) => {
            console.log("ResponseStopped for:", messageId);
            if (isGenerating && messageId === currentAiMessageId) {
                stopGenerationState("Response stopped.");
            }
            
            // Add interrupted marker to the message
            const messageElement = document.querySelector(`.message[data-message-id="${messageId}"] .message-content`);
            if (messageElement && !messageElement.textContent.includes('[Response interrupted]')) {
                messageElement.innerHTML += '<br><em style="color: var(--secondary-color);">[Response interrupted]</em>';
            }
        });
        
        // Error handling
        connection.on("Error", (errorMessage) => {
            console.error("SignalR Server Error:", errorMessage);
            showToast(errorMessage, "error");
            if (isGenerating) {
                stopGenerationState("Error occurred.");
            }
        });

        // --- Add handler for MessageDeleted event ---
        connection.on("MessageDeleted", (messageId) => {
            console.log("MessageDeleted event received for:", messageId);
            const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (messageElement) {
                messageElement.style.transition = 'opacity 0.5s ease';
                messageElement.style.opacity = '0';
                setTimeout(() => {
                    messageElement.remove();
                    console.log("Removed deleted message element:", messageId);
                }, 500); // Remove after fade out
            } else {
                console.warn("Could not find message element to delete:", messageId);
            }
        });
    }

    // --- UI State Management ---
    function updateConnectionStatus(status, message) {
        connectionStatus.className = `connection-status ${status}`;
        connectionStatus.textContent = message;
    }

    function toggleConnectionState(connected) {
        isConnected = connected;
        connectBtn.disabled = connected;
        disconnectBtn.disabled = !connected;
        toggleUIState(connected);
    }

    function toggleUIState(enabled) {
        messageInput.disabled = !enabled || isGenerating;
        sendBtn.disabled = !enabled || isGenerating;
        uploadBtn.disabled = !enabled || isGenerating;
        thinkingToggle.disabled = !enabled;
    }

    function startGenerationState(messageId, statusText = "AI is responding...") {
        isGenerating = true;
        currentAiMessageId = messageId;
        updateGeneratingStateUI(statusText);
        
        // Show stop button
        stopBtn.classList.remove('hidden');
        stopBtn.disabled = false;
    }

    function stopGenerationState(statusText = "") {
        isGenerating = false;
        currentAiMessageId = null;
        currentThinkingMessageId = null;
        updateGeneratingStateUI(statusText);
        
        // Hide stop button
        stopBtn.classList.add('hidden');
        stopBtn.disabled = true;
    }

    function updateGeneratingStateUI(statusText = "") {
        if (isGenerating) {
            // Show stop button
            stopBtn.classList.remove('hidden');
            stopBtn.disabled = false; // Ensure stop button is enabled
            
            // Update status text
            statusIndicator.innerHTML = statusText ? 
                `<div class="loading-indicator"></div> ${escapeHtml(statusText)}` : 
                '<div class="loading-indicator"></div> AI is responding...';
                
            console.log("updateGeneratingStateUI: Stop button should be visible");
        } else {
            // Hide stop button
            stopBtn.classList.add('hidden');
            stopBtn.disabled = true; // Disable when not generating
            
            // Update status text
            statusIndicator.textContent = statusText || "";
            
            console.log("updateGeneratingStateUI: Stop button should be hidden");
        }
        
        // Update button states based on *both* connection and generation status
        toggleUIState(isConnected);
    }

    function updateTokenUsage(inputTokens, outputTokens, cost) {
        inputTokensEl.textContent = inputTokens.toLocaleString();
        outputTokensEl.textContent = outputTokens.toLocaleString();
        totalTokensEl.textContent = (inputTokens + outputTokens).toLocaleString();
        tokenCostEl.textContent = `$${cost.toFixed(4)}`;
    }

    // --- Messaging ---
    sendBtn.addEventListener('click', sendMessageHandler);

    async function sendMessageHandler() {
        if (!isConnected || !connection || isGenerating) return;

        const content = messageInput.value.trim();
        const filesToSend = [...uploadedFiles]; // Copy the array
        
        if (!content && filesToSend.length === 0) {
            showToast("Please enter a message or add files.", "warning");
            return;
        }

        const chatId = chatIdInput.value.trim();
        const enableThinking = thinkingToggle.checked;
        
        // --- Read image settings from new inputs ---
        const imageSize = imageSizeSelect.value || null; // Get value, null if empty
        const numImagesRaw = numImagesInput.value;
        const numImages = numImagesRaw ? parseInt(numImagesRaw, 10) : null;
        const outputFormat = outputFormatSelect.value || null;
        const enableSafetyChecker = enableSafetyCheckerToggle.checked; // Boolean
        const safetyTolerance = safetyToleranceSelect.value || null;

        // Start UI blocking immediately
        startGenerationState(null, "Sending..."); 

        try {
            const fileIds = filesToSend.map(file => file.id);

            // Use the method signature that includes the new parameters
            if (fileIds.length > 0) {
                await connection.invoke("SendMessageWithAttachments", 
                    chatId, 
                    content, 
                    fileIds, 
                    enableThinking, 
                    // Add image params
                    imageSize, 
                    numImages, 
                    outputFormat, 
                    enableSafetyChecker, 
                    safetyTolerance);
                clearUploadedFiles(); // Clear only if sent successfully
            } else {
                await connection.invoke("SendMessage", 
                    chatId, 
                    content, 
                    enableThinking,
                    // Add image params
                    imageSize, 
                    numImages, 
                    outputFormat, 
                    enableSafetyChecker, 
                    safetyTolerance);
            }

            messageInput.value = ''; // Clear input after successful send invocation
            messageInput.style.height = 'auto'; // Reset height
            // NOTE: We don't call stopGenerationState() here. We wait for ResponseCompleted/Stopped/Error events.

        } catch (err) {
            console.error("Error sending message via SignalR:", err);
            showToast(`Failed to send message: ${err.message || 'Unknown error'}`, "error");
            stopGenerationState("Send failed."); // Stop generation state on SignalR error
        }
    }

    // --- Message Display ---
    function addMessageToChat(message) {
        console.log(`addMessageToChat called for ${message.messageId}, isFromAi: ${message.isFromAi}`);
        const statusMsg = messageList.querySelector('.status-message');
        if (statusMsg) messageList.removeChild(statusMsg);

        let messageElement = document.querySelector(`.message[data-message-id="${message.messageId}"]`);
        const isUpdate = !!messageElement;

        if (!messageElement) {
            messageElement = document.createElement('div');
            messageElement.className = `message ${message.isFromAi ? 'ai' : 'user'}`;
            messageElement.setAttribute('data-message-id', message.messageId);

            const contentElement = document.createElement('div');
            contentElement.className = 'message-content';
            messageElement.appendChild(contentElement);

            const attachmentsContainer = document.createElement('div');
            attachmentsContainer.className = 'file-attachments';
            messageElement.appendChild(attachmentsContainer);

            if (!message.isFromAi) {
                const editBtn = document.createElement('button');
                editBtn.className = 'edit-btn';
                editBtn.innerHTML = 'âœï¸';
                editBtn.title = 'Edit message';
                editBtn.addEventListener('click', () => showEditMessageDialog(message.messageId, message.content));
                messageElement.appendChild(editBtn);

                // Add Regenerate button for user messages
                const regenerateBtn = document.createElement('button');
                regenerateBtn.className = 'regenerate-btn btn-icon'; // You might want specific styling
                regenerateBtn.innerHTML = 'ðŸ”„'; // Refresh icon
                regenerateBtn.title = 'Regenerate AI response';
                regenerateBtn.style.position = 'absolute'; // Style similar to edit button
                regenerateBtn.style.top = '30px'; // Position below edit button
                regenerateBtn.style.right = '5px';
                regenerateBtn.style.opacity = '0'; // Initially hidden
                regenerateBtn.style.transition = 'opacity 0.2s';
                regenerateBtn.style.background = 'rgba(255, 255, 255, 0.7)';
                regenerateBtn.style.border = 'none';
                regenerateBtn.style.borderRadius = '50%';
                regenerateBtn.style.padding = '3px 6px';
                regenerateBtn.style.cursor = 'pointer';
                regenerateBtn.style.fontSize = '0.8em';
                regenerateBtn.style.lineHeight = '1';
                regenerateBtn.style.color = 'var(--dark-gray)';

                regenerateBtn.addEventListener('click', () => regenerateResponse(message.messageId));
                messageElement.appendChild(regenerateBtn);

                // Show regenerate button on hover (along with edit button)
                messageElement.addEventListener('mouseenter', () => {
                     editBtn.style.opacity = '1';
                     regenerateBtn.style.opacity = '1';
                 });
                 messageElement.addEventListener('mouseleave', () => {
                     editBtn.style.opacity = '0';
                     regenerateBtn.style.opacity = '0';
                 });
            }
            messageList.appendChild(messageElement);
        } else {
            console.log(`Updating existing message element for ${message.messageId}`);
        }

        // Update content (relevant for full messages overriding streamed content)
        const contentElement = messageElement.querySelector('.message-content');
        if (contentElement) {
            // Set the raw content for potential streaming updates later
            messageElement.dataset.rawContent = message.content;
            contentElement.innerHTML = formatMessageContent(message.content);
            if (message.isFromAi) {
                addCodeBlockActions(messageElement); // Add actions specifically to this message
            }
        }

        // Always scroll and fetch attachments
        scrollToBottom();
        if (connection && connection.state === signalR.HubConnectionState.Connected) {
            connection.invoke("GetMessageAttachments", message.messageId).catch(err => console.error("Error getting attachments:", err));
        }
        return messageElement; // Return the element for potential reuse
    }

    // Finds or creates a message element
    function findOrCreateMessageElement(messageId, isFromAi) {
        let messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
        if (!messageElement) {
            // Create a new message element
            messageElement = document.createElement('div');
            messageElement.className = `message ${isFromAi ? 'ai' : 'user'}`;
            messageElement.setAttribute('data-message-id', messageId);
            messageElement.dataset.rawContent = "";
            
            // Create message content container
            const contentElement = document.createElement('div');
            contentElement.className = 'message-content';
            messageElement.appendChild(contentElement);
            
            // Create file attachments container
            const attachmentsContainer = document.createElement('div');
            attachmentsContainer.className = 'file-attachments';
            messageElement.appendChild(attachmentsContainer);
            
            // Add edit button for user messages (not AI)
            if (!isFromAi) {
                const editBtn = document.createElement('button');
                editBtn.className = 'edit-btn';
                editBtn.innerHTML = 'âœï¸';
                editBtn.title = 'Edit message';
                editBtn.addEventListener('click', () => showEditMessageDialog(messageId, messageElement.dataset.rawContent));
                messageElement.appendChild(editBtn);
            }
            
            // Add to the message list
            messageList.appendChild(messageElement);
            
            // Clear any status messages
            const statusMsg = messageList.querySelector('.status-message');
            if (statusMsg) messageList.removeChild(statusMsg);
        }
        return messageElement;
    }

    function updateStreamingMessage(messageId, contentChunk) {
        try {
            if (!messageId) {
                console.error("Cannot update streaming: messageId is empty");
                return;
            }
            
            const messageElement = findOrCreateMessageElement(messageId, true); // AI messages stream
            if (messageElement) {
                // Append raw chunk to dataset for full content
                if (messageElement.dataset.rawContent === undefined) {
                    messageElement.dataset.rawContent = "";
                }
                
                messageElement.dataset.rawContent += contentChunk;
                
                // Render immediately
                renderStreamedContent(messageId);
                
                // Scroll as chunks arrive
                scrollToBottom();
            } else {
                console.error(`Failed to find or create message element for ${messageId}`);
            }
        } catch (error) {
            console.error("Error in updateStreamingMessage:", error);
        }
    }

    // Renders the accumulated raw content with markdown
    function renderStreamedContent(messageId) {
        const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
        if (messageElement && messageElement.dataset.rawContent !== undefined) {
            const contentElement = messageElement.querySelector('.message-content');
            if (contentElement) {
                contentElement.innerHTML = formatMessageContent(messageElement.dataset.rawContent); 
            }
        }
    }

    function updateThinkingChunk(messageId, chunk) {
        let thinkingElement = document.getElementById(`thinking-${messageId}`);
        
        if (!thinkingElement) {
            // Create thinking bubble if it doesn't exist
            thinkingElement = document.createElement('div');
            thinkingElement.className = 'message ai thinking';
            thinkingElement.id = `thinking-${messageId}`;
            thinkingElement.setAttribute('data-message-id', `thinking-${messageId}`);
            
            // Enhanced styling for thinking content - add a different background color and border
            thinkingElement.innerHTML = `
                <div class="message-header">
                    <span class="thinking-label"><i class="fa fa-brain"></i> AI's Reasoning Process</span>
                </div>
                <div class="message-content thinking-content"></div>
            `;
            
            // Add custom styles for thinking content
            const style = document.createElement('style');
            style.textContent = `
                .message.ai.thinking {
                    background-color: #f0f7ff;
                    border-left: 3px solid #4a7bff;
                    margin-bottom: 10px;
                    animation: fade-in 0.3s ease-in-out;
                }
                .thinking-content {
                    font-size: 0.95em;
                    color: #444;
                    white-space: pre-wrap;
                }
                .thinking-label {
                    color: #4a7bff;
                    font-weight: bold;
                    font-size: 0.9em;
                }
                .message-header {
                    border-bottom: 1px solid #e1e4e8;
                    padding-bottom: 5px;
                    margin-bottom: 8px;
                }
                @keyframes fade-in {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            // Insert thinking bubble before the actual AI message bubble if it exists
            const aiMessageElement = document.querySelector(`.message.ai[data-message-id="${messageId}"]`);
            if (aiMessageElement) {
                messageList.insertBefore(thinkingElement, aiMessageElement);
            } else {
                messageList.appendChild(thinkingElement);
            }
            
            // Make sure we have a currentThinkingMessageId set
            currentThinkingMessageId = messageId;
        }

        const contentElement = thinkingElement.querySelector('.thinking-content');
        if (contentElement) {
            // Process for markdown and highlight as code if it looks like code
            contentElement.innerHTML += formatMessageContent(chunk);
            scrollToBottom();
        }
    }

    function formatMessageContent(content) {
        if (content === null || content === undefined) return '';
        // Let marked handle sanitization if configured, otherwise use escapeHtml
        // For now, assuming marked handles it. If not, uncomment escapeHtml call.
        // const sanitized = escapeHtml(content);
        const sanitized = content; 
        try {
            return marked.parse(sanitized); // Parses content using marked.js
        } catch (e) {
            console.error("Error parsing markdown:", e);
            return escapeHtml(sanitized); // Fallback
        }
    }

    function scrollToBottom() {
        setTimeout(() => {
            messageList.scrollTop = messageList.scrollHeight;
        }, 50); 
    }

    // --- Attachments ---
    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileSelection);
    clearUploadsBtn.addEventListener('click', clearUploadedFiles);

    async function handleFileSelection(e) {
        if (!e.target.files.length) return;
        const files = Array.from(e.target.files);
        fileInput.value = ''; // Clear the input immediately
        
        uploadBtn.disabled = true; // Disable while processing files
        showToast(`Processing ${files.length} file(s)...`, "info");

        const uploadPromises = files.map(file => uploadFile(file));

        try {
            const results = await Promise.all(uploadPromises);
            const successfulUploads = results.filter(r => r !== null);
            if (successfulUploads.length > 0) {
                showToast(`Added ${successfulUploads.length} file(s) to attachment list.`, "success");
            } 
            if (successfulUploads.length < files.length) {
                 showToast(`${files.length - successfulUploads.length} file upload(s) failed.`, "error");
            }
        } catch (err) {
            // Error handling is mostly within uploadFile
            console.error("Error during file processing batch:", err);
        } finally {
            // Re-enable upload button based on connection/generation state
            toggleUIState(isConnected); 
        }
    }

    // Uploads file via API and adds to the *local* list
    async function uploadFile(file) {
        const token = tokenInput.value.trim();
        if (!token) {
            showToast("Auth Token required for upload", "error");
            return null; 
        }

        // Optional: Optimize image client-side before uploading if needed
        // const fileToUpload = await optimizeFileIfNeeded(file); 
        const fileToUpload = file;

        const formData = new FormData();
        formData.append('file', fileToUpload);

        const requestId = Date.now().toString() + Math.random();
        pendingRequests.add(requestId);

        try {
            const response = await fetch('/api/file/upload', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` },
                body: formData
            });

            if (!response.ok) {
                let errorText = `Upload failed (${response.status})`;
                try {
                    const errorData = await response.json();
                    errorText = errorData.detail || errorData.title || errorText;
                } catch { /* Ignore if response is not JSON */ }
                throw new Error(errorText);
            }

            const fileData = await response.json();
            addFileToUploadsList(fileData); // Add to UI/local state
            return fileData; // Return data for Promise.all

        } catch (err) {
            console.error(`Error uploading file ${fileToUpload.name}:`, err);
            showToast(`Upload Error: ${err.message || 'Unknown error'}`, "error");
            return null; // Indicate failure for this file
        } finally {
            pendingRequests.delete(requestId);
        }
    }

    function addFileToUploadsList(fileData) {
        const statusMsg = uploadsList.querySelector('.status-message');
        if (statusMsg) uploadsList.removeChild(statusMsg);

        // Check if file already in list to prevent duplicates
        if (uploadedFiles.some(f => f.id === fileData.id)) {
            console.warn("Attempted to add duplicate file:", fileData.fileName);
            return; 
        }

        uploadedFiles.push(fileData);

        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.setAttribute('data-file-id', fileData.id);

        const token = tokenInput.value.trim();
        let fileUrl = `/api/file/${fileData.id}`;
        const authenticatedFileUrl = `${fileUrl}?token=${encodeURIComponent(token)}`; // Add token for preview/link

        // File Preview/Icon
        const previewContainer = document.createElement('div');
        previewContainer.className = 'file-icon'; // Using file-icon class for consistency
        if (fileData.fileType === 'Image') {
            const img = document.createElement('img');
            img.src = authenticatedFileUrl; 
            img.alt = fileData.fileName;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            previewContainer.appendChild(img);
        } else {
            previewContainer.innerHTML = getFileIcon(fileData.fileType);
        }
        fileItem.appendChild(previewContainer);

        // File Info
        const fileInfo = document.createElement('div');
        fileInfo.className = 'file-info';
        fileInfo.innerHTML = `
            <div class="file-name" title="${escapeHtml(fileData.fileName)}">${escapeHtml(fileData.fileName)}</div>
            <div class="file-size">${formatFileSize(fileData.fileSize)}</div>
        `;
        fileItem.appendChild(fileInfo);

        // Actions (Remove Button)
        const actions = document.createElement('div');
        actions.className = 'file-actions';
        const removeBtn = document.createElement('button');
        removeBtn.className = 'btn-icon'; 
        removeBtn.innerHTML = 'âŒ'; 
        removeBtn.title = 'Remove';
        removeBtn.onclick = () => removeUploadedFile(fileData.id);
        actions.appendChild(removeBtn);
        fileItem.appendChild(actions);

        uploadsList.appendChild(fileItem);
    }

    function removeUploadedFile(fileId) {
        uploadedFiles = uploadedFiles.filter(file => file.id !== fileId);
        const fileItem = uploadsList.querySelector(`.file-item[data-file-id="${fileId}"]`);
        if (fileItem) uploadsList.removeChild(fileItem);
        if (uploadedFiles.length === 0) {
            uploadsList.innerHTML = '<div class="status-message">No files attached</div>';
        }
    }

    function clearUploadedFiles() {
        uploadedFiles = [];
        uploadsList.innerHTML = '<div class="status-message">No files attached</div>';
    }

    // Adds attachment info to an existing message bubble
    function addFileAttachmentToMessage(messageId, fileAttachment) {
        const messageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
        if (!messageElement) return;

        const attachmentsContainer = messageElement.querySelector('.file-attachments');
        if (!attachmentsContainer) return;

        // Avoid adding duplicate visual elements
        if (attachmentsContainer.querySelector(`[data-file-id="${fileAttachment.id}"]`)) return;

        const attachmentElement = document.createElement('div');
        attachmentElement.className = 'file-attachment'; // Use the class for styling
        attachmentElement.setAttribute('data-file-id', fileAttachment.id);

        const token = tokenInput.value.trim();
        let fileUrl = fileAttachment.url || `/api/file/${fileAttachment.id}`;
        if (fileUrl.startsWith('/')) {
            fileUrl = window.location.origin + fileUrl;
        }
        const authenticatedFileUrl = `${fileUrl}?token=${encodeURIComponent(token)}`;

        // Simplified representation in message bubble
        attachmentElement.innerHTML = `
             <div class="attachment-icon">${getFileIcon(fileAttachment.fileType)}</div>
             <div class="attachment-name">${escapeHtml(fileAttachment.fileName)}</div>
             <a href="${authenticatedFileUrl}" target="_blank" title="Open/Download File" class="btn-icon" style="font-size: 0.8em;">ðŸ”—</a>
         `;
        // Adjust styling as needed
        attachmentElement.style.padding = '5px 8px';
        attachmentElement.style.fontSize = '0.8em';
        attachmentElement.style.maxWidth = '200px'; 

        attachmentsContainer.appendChild(attachmentElement);
    }

    // --- Utility Functions ---
    function getFileIcon(fileType) {
        switch (fileType) {
            case 'PDF': return 'ðŸ“„';
            case 'Image': return 'ðŸ–¼ï¸';
            case 'Document': return 'ðŸ“';
            case 'Video': return 'ðŸŽ¥';
            case 'Audio': return 'ðŸŽµ';
            default: return 'ðŸ“Ž';
        }
    }

    function formatFileSize(bytes) {
        if (!bytes || bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
    }

    function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return '';
        return unsafe
             .replace(/&/g, "&amp;")
             .replace(/</g, "&lt;")
             .replace(/>/g, "&gt;")
             .replace(/"/g, "&quot;")
             .replace(/'/g, "&#039;");
    }

    // --- Stop Generating ---
    stopBtn.addEventListener('click', async () => {
        if (!connection || !isConnected || !isGenerating) {
            console.warn("Cannot stop: not connected or not generating");
            return;
        }
        
        if (!currentAiMessageId) {
            console.warn("No current AI message ID to stop");
            stopGenerationState("No active response");
            return;
        }
        
        const messageIdToStop = currentAiMessageId;
        const token = tokenInput.value.trim();
        
        showToast("Stopping AI response...", "info");
        console.log(`Attempting to stop response for message ${messageIdToStop}`);
        
        try {
            stopBtn.disabled = true;
            
            // Make HTTP POST request to the controller endpoint
            const response = await fetch(`/api/Chat/StopResponse/${messageIdToStop}`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json' // Although no body, specify content type
                }
                // No body is needed for this specific request
            });

            if (response.ok) {
                console.log("Stop request sent successfully via HTTP.");
                // The backend cancellation will trigger SignalR events (like ResponseStopped)
                // which the client already handles. We might not need immediate UI changes here.
                showToast("Stop request sent.", "success");
            } else {
                 // Handle specific error scenarios based on response status
                 let errorMsg = `Failed to stop response (HTTP ${response.status})`;
                 try {
                    const errorData = await response.json();
                    errorMsg = errorData.message || errorData.title || errorMsg;
                 } catch { /* Ignore if response is not JSON */ }
                 
                 console.error("Error invoking StopResponse via HTTP:", response.status, errorMsg);
                 showToast(errorMsg, "error");
                 // Re-enable button only if the request failed
                 stopBtn.disabled = false; 
            }
            
            // Note: Unlike invoke, fetch doesn't inherently throw on non-2xx status unless network error occurs.
            // We handle non-ok responses above.

        } catch (err) {
            // Catch network errors or other exceptions during fetch
            console.error("Exception during StopResponse fetch:", err);
            showToast(`Error sending stop request: ${err.message || 'Network error'}`, "error");
            stopBtn.disabled = false; // Re-enable on fetch exception
        }
        // Don't immediately re-enable button on success; wait for SignalR confirmation (ResponseStopped)
    });

    // --- Edit Message Dialog (Simplified - Add back complex version if needed) ---
    function showEditMessageDialog(messageId, currentContent) {
        const newContent = prompt("Edit your message:", currentContent);
        if (newContent !== null && newContent.trim() !== currentContent.trim()) {
            if (!newContent.trim()) {
                showToast("Message cannot be empty.", "warning");
                return;
            }
            const chatId = chatIdInput.value.trim();
            if (connection && isConnected) {
                 connection.invoke("EditMessage", chatId, messageId, newContent.trim())
                     .then(() => {
                         showToast("Message edit request sent.", "info");
                         // Update UI immediately for responsiveness (optional)
                         const msgElement = document.querySelector(`.message[data-message-id="${messageId}"] .message-content`);
                         if(msgElement) msgElement.innerHTML = formatMessageContent(newContent.trim());
                     })
                     .catch(err => {
                         console.error("Error invoking EditMessage:", err);
                         showToast(`Failed to send edit request: ${err.message}`, "error");
                     });
            }
        }
    }

    // --- Initialization & Local Storage ---
    window.addEventListener('load', () => {
        const savedToken = localStorage.getItem('authToken');
        const savedChatId = localStorage.getItem('chatId');
        if (savedToken) tokenInput.value = savedToken;
        if (savedChatId) chatIdInput.value = savedChatId;
        
        // Debug - log stop button state
        console.log("Initial stop button state:");
        console.log(`Stop button element:`, stopBtn);
        console.log(`Stop button display: ${window.getComputedStyle(stopBtn).display}`);
        console.log(`Stop button hidden: ${stopBtn.classList.contains('hidden')}`);
        console.log(`Stop button disabled: ${stopBtn.disabled}`);
    });

    tokenInput.addEventListener('input', () => localStorage.setItem('authToken', tokenInput.value.trim()));
    chatIdInput.addEventListener('input', () => localStorage.setItem('chatId', chatIdInput.value.trim()));

    // --- Toast Notifications ---
    function showToast(message, type = "info", duration = 4000) {
        const toastContainer = document.getElementById('toastContainer');
        if (!toastContainer) return;
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
        
        // Trigger animation
        setTimeout(() => { toast.classList.add('show'); }, 50);
        
        // Auto-remove toast
        setTimeout(() => {
            toast.classList.remove('show');
            // Remove element after transition
            toast.addEventListener('transitionend', () => toast.remove());
        }, duration);
    }

    // --- Initial UI State ---
    toggleUIState(false); // Start disabled
    disconnectBtn.disabled = true;

    // Add code block actions (like copy buttons)
    function addCodeBlockActions(parentElement = document) {
        parentElement.querySelectorAll('.message.ai pre > code').forEach(codeBlock => {
            const pre = codeBlock.parentNode;
            // Avoid adding multiple buttons
            if (pre.querySelector('.copy-code-btn')) return;

            pre.style.position = 'relative'; // Needed for absolute positioning of button

            const button = document.createElement('button');
            button.textContent = 'Copy';
            button.className = 'copy-code-btn btn btn-sm btn-secondary'; // Use some btn styles
            button.style.position = 'absolute';
            button.style.top = '5px';
            button.style.right = '5px';
            button.style.opacity = '0.7';

            button.onclick = () => {
                navigator.clipboard.writeText(codeBlock.textContent)
                    .then(() => {
                        button.textContent = 'Copied!';
                        setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                    })
                    .catch(err => {
                        console.error('Failed to copy code:', err);
                        button.textContent = 'Error';
                        setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                    });
            };
            pre.appendChild(button);
        });
    }

    // --- Chat History --- 
    async function loadChatHistory(chatId, token) {
        console.log(`Loading history for chat: ${chatId}`);
        messageList.innerHTML = '<div class="status-message">Loading history...</div>'; // Initial loading state
        try {
            const response = await fetch(`/api/Chat/${chatId}`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            if (!response.ok) {
                throw new Error(`Failed to fetch history: ${response.status}`);
            }
            const historyData = await response.json();
            messageList.innerHTML = ''; // Clear loading message

            if (historyData.messages && historyData.messages.length > 0) {
                console.log(`Displaying ${historyData.messages.length} history messages`);
                
                // First sort messages by timestamp to ensure proper order
                const sortedMessages = [...historyData.messages].sort((a, b) => {
                    return new Date(a.createdAt) - new Date(b.createdAt);
                });
                
                sortedMessages.forEach(msg => {
                    console.log(`Adding history message: ${msg.id.substring(0, 8)}... (${msg.isFromAi ? 'AI' : 'User'})`);
                    // Use the same function to add messages
                    addMessageToChat({
                        messageId: msg.id, 
                        content: msg.content || "", // Ensure content is never null
                        isFromAi: msg.isFromAi,
                        timestamp: msg.createdAt 
                    });
                });
                
                // Apply code block actions after all messages are loaded
                addCodeBlockActions();
                
                // Scroll to the most recent message
                scrollToBottom();
            } else {
                messageList.innerHTML = '<div class="status-message">No messages yet. Start chatting!</div>';
            }

            // Update token usage if history provides it
            if (historyData.inputTokens !== undefined || historyData.outputTokens !== undefined) {
                updateTokenUsage(historyData.inputTokens || 0, historyData.outputTokens || 0, historyData.totalCost || 0);
            }

        } catch (error) {
            console.error("Error loading chat history:", error);
            messageList.innerHTML = `<div class="status-message error-message">Error loading history: ${error.message}</div>`;
        }
    }

    // Add keyboard shortcut to stop generation with Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && isGenerating) {
            console.log("Escape key pressed - attempting to stop response");
            showStopButton();
            stopCurrentResponse();
        }
    });
    
    // Function to manually show the stop button
    function showStopButton() {
        if (isGenerating) {
            console.log("Showing stop button manually");
            stopBtn.style.display = 'inline-flex';
            stopBtn.classList.remove('hidden');
            stopBtn.disabled = false;
        }
    }
    
    // Function to stop current response - called directly from UI
    function stopCurrentResponse() {
        // Make sure the button is visible first
        showStopButton();
        
        if (stopBtn.disabled) {
            console.log("Stop button is disabled, enabling it");
            stopBtn.disabled = false;
        }
        
        console.log("stopCurrentResponse called, isGenerating:", isGenerating, "connection:", !!connection);
        
        // Use the existing event handler
        if (connection && isConnected && isGenerating) {
            console.log("Triggering stop button click event");
            const event = new Event('click');
            stopBtn.dispatchEvent(event);
        } else {
            console.log("Cannot stop: not connected or not generating");
            showToast("Cannot stop response - not generating or not connected", "warning");
        }
    }

    function hideStopButton() {
        stopBtn.classList.add('hidden');
        stopBtn.disabled = true;
    }
    
    function hideThinkingOutput() {
        const thinkingElements = document.querySelectorAll('.message.ai.thinking');
        thinkingElements.forEach(element => {
            element.classList.add('hidden');
            // Optionally remove after a delay
            setTimeout(() => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            }, 300);
        });
        currentThinkingMessageId = null;
    }

    // --- Add function to call RegenerateResponse hub method ---
    async function regenerateResponse(userMessageId) {
        if (!isConnected || !connection || isGenerating) {
            showToast("Cannot regenerate response while disconnected or AI is busy.", "warning");
            return;
        }

        const chatId = chatIdInput.value.trim();
        if (!chatId || !userMessageId) {
            showToast("Chat ID and User Message ID are required.", "error");
            return;
        }

        console.log(`Requesting regeneration for user message: ${userMessageId}`);
        showToast("Requesting AI regeneration...", "info");
        startGenerationState(null, "Regenerating AI response..."); // Start loading state

        try {
            await connection.invoke("RegenerateResponse", chatId, userMessageId);
            // The backend will handle deleting the old AI message and sending a new one.
            // The existing SignalR handlers (MessageDeleted, ReceiveMessageChunk, ResponseCompleted) will manage the UI updates.
        } catch (err) {
            console.error("Error invoking RegenerateResponse:", err);
            showToast(`Failed to regenerate response: ${err.message || 'Unknown error'}`, "error");
            stopGenerationState("Regeneration failed."); // Stop loading state on error
        }
    }
</script>
</body>
</html> 